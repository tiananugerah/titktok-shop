/**
 * tiktok shop openapi
 * sdk for apis
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AffiliateSeller202405CreateOpenCollaborationRequestBody } from '../model/affiliateSeller/V202405/CreateOpenCollaborationRequestBody';
import { AffiliateSeller202405CreateOpenCollaborationResponse } from '../model/affiliateSeller/V202405/CreateOpenCollaborationResponse';
import { AffiliateSeller202405CreateTargetCollaborationRequestBody } from '../model/affiliateSeller/V202405/CreateTargetCollaborationRequestBody';
import { AffiliateSeller202405CreateTargetCollaborationResponse } from '../model/affiliateSeller/V202405/CreateTargetCollaborationResponse';
import { AffiliateSeller202405EditOpenCollaborationSettingsRequestBody } from '../model/affiliateSeller/V202405/EditOpenCollaborationSettingsRequestBody';
import { AffiliateSeller202405EditOpenCollaborationSettingsResponse } from '../model/affiliateSeller/V202405/EditOpenCollaborationSettingsResponse';
import { AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse } from '../model/affiliateSeller/V202405/GenerateAffiliateProductPromotionLinkResponse';
import { AffiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody } from '../model/affiliateSeller/V202405/RemoveCreatorFromOpenCollaborationRequestBody';
import { AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse } from '../model/affiliateSeller/V202405/RemoveCreatorFromOpenCollaborationResponse';
import { AffiliateSeller202405SearchSellerAffiliateOrdersResponse } from '../model/affiliateSeller/V202405/SearchSellerAffiliateOrdersResponse';
import { AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody } from '../model/affiliateSeller/V202405/SellerSearchAffiliateOpenCollaborationProductRequestBody';
import { AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse } from '../model/affiliateSeller/V202405/SellerSearchAffiliateOpenCollaborationProductResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://open-api.tiktokglobalshop.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AffiliateSellerV202405ApiApiKeys {
}

export class AffiliateSellerV202405Api {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static readonly apiName = 'AffiliateSellerV202405Api' as const;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AffiliateSellerV202405ApiApiKeys, value: string) {
        (this.authentications as any)[AffiliateSellerV202405ApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This API is used to edit a Seller\'s open collaboration settings. It allows you to enroll your existing product catalog and all future products into an open collaboration plan. It also allows you to turn this setting off at any point. By default, this option is turned off for all Sellers. 
     * @summary EditOpenCollaborationSettings
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param shopCipher 
     * @param EditOpenCollaborationSettingsRequestBody 
     */
    public async OpenCollaborationSettingsPost (xTtsAccessToken: string, contentType: string, shopCipher?: string, EditOpenCollaborationSettingsRequestBody?: AffiliateSeller202405EditOpenCollaborationSettingsRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405EditOpenCollaborationSettingsResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/open_collaboration_settings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling OpenCollaborationSettingsPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling OpenCollaborationSettingsPost.');
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(EditOpenCollaborationSettingsRequestBody, "AffiliateSeller202405EditOpenCollaborationSettingsRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405EditOpenCollaborationSettingsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405EditOpenCollaborationSettingsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API is used to remove creators from open collaboration. Please note, due to current platform design, creators can still rejoin an open collaboration after removal. Partners/Sellers can call this API again to remove the creator again. 
     * @summary RemoveCreatorFromOpenCollaboration
     * @param openCollaborationId Open collaboration ID. This API is only applicable to the seller removing creators from open collaboration.
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param shopCipher 
     * @param RemoveCreatorFromOpenCollaborationRequestBody 
     */
    public async OpenCollaborationsOpenCollaborationIdRemoveCreatorPost (openCollaborationId: string, xTtsAccessToken: string, contentType: string, shopCipher?: string, RemoveCreatorFromOpenCollaborationRequestBody?: AffiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/open_collaborations/{open_collaboration_id}/remove_creator'
            .replace('{' + 'open_collaboration_id' + '}', encodeURIComponent(String(openCollaborationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'openCollaborationId' is not null or undefined
        if (openCollaborationId === null || openCollaborationId === undefined) {
            throw new Error('Required parameter openCollaborationId was null or undefined when calling OpenCollaborationsOpenCollaborationIdRemoveCreatorPost.');
        }

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling OpenCollaborationsOpenCollaborationIdRemoveCreatorPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling OpenCollaborationsOpenCollaborationIdRemoveCreatorPost.');
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(RemoveCreatorFromOpenCollaborationRequestBody, "AffiliateSeller202405RemoveCreatorFromOpenCollaborationRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405RemoveCreatorFromOpenCollaborationResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API allows the seller to create an open collaboration. You create an open collaboration by selecting products and setting a commission rate.
     * @summary CreateOpenCollaboration
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param shopCipher 
     * @param CreateOpenCollaborationRequestBody 
     */
    public async OpenCollaborationsPost (xTtsAccessToken: string, contentType: string, shopCipher?: string, CreateOpenCollaborationRequestBody?: AffiliateSeller202405CreateOpenCollaborationRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405CreateOpenCollaborationResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/open_collaborations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling OpenCollaborationsPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling OpenCollaborationsPost.');
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(CreateOpenCollaborationRequestBody, "AffiliateSeller202405CreateOpenCollaborationRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405CreateOpenCollaborationResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405CreateOpenCollaborationResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API is used to search the information of products with open collaboration by category, commission rate, and keywords. It will return all products on the TikTok Shop Affiliate Product Marketplace that are in an open collaboration. Sellers can only search for open collaboration within the regions they are registered to sell in.
     * @summary SellerSearchAffiliateOpenCollaborationProduct
     * @param pageSize The number of results to be returned per page. Valid range: [1-20].
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param sortOrder The sort order for the sort_field parameter. Default: ASC Possible values: - ASC: Ascending order - DESC: Descending order
     * @param sortField The returned results will be sorted by the specified field. See the description of the field values in the request body for more information about each field. Default: commission_rate Possible values: - commission_rate - product_sales_price - commission - units_sold
     * @param pageToken An opaque token used to retrieve the next page of a paginated result set. Retrieve this value from the result of the next_page_token from a previous response. It is not needed for the first page.
     * @param shopCipher 
     * @param SellerSearchAffiliateOpenCollaborationProductRequestBody 
     */
    public async OpenCollaborationsProductsSearchPost (pageSize: number, xTtsAccessToken: string, contentType: string, sortOrder?: string, sortField?: string, pageToken?: string, shopCipher?: string, SellerSearchAffiliateOpenCollaborationProductRequestBody?: AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/open_collaborations/products/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling OpenCollaborationsProductsSearchPost.');
        }

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling OpenCollaborationsProductsSearchPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling OpenCollaborationsProductsSearchPost.');
        }

        if (sortOrder !== undefined) {
            localVarQueryParameters['sort_order'] = ObjectSerializer.serialize(sortOrder, "string");
        }

        if (sortField !== undefined) {
            localVarQueryParameters['sort_field'] = ObjectSerializer.serialize(sortField, "string");
        }

        if (pageToken !== undefined) {
            localVarQueryParameters['page_token'] = ObjectSerializer.serialize(pageToken, "string");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['page_size'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(SellerSearchAffiliateOpenCollaborationProductRequestBody, "AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405SellerSearchAffiliateOpenCollaborationProductResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API allows the partner to retrieve a list of affiliate orders (orders which are affiliate-commission eligible) generated by a seller, returning the order ID and the product ID. Using this, the partner can track their affiliate-conversions on behalf of a seller, using the order ID. For now, this API returns all historical Affiliate Orders. We do not provide any filtering mechanisms (based on timestamp) at this time. We will provide this functionality in a future iteration. Thus this API is technically a \"Get Affiliate Orders List\" at this stage, but it will be improved in the future to be a search based API (with robust filtering).
     * @summary SearchSellerAffiliateOrders
     * @param pageSize The size of one page, which must be greater than 0 and less than or equal to 50.
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param version The interface version you want to access
     * @param pageToken Pagination offset determines where you begin to search for. It\&#39;s empty when raise your first request.
     * @param shopCipher 
     */
    public async OrdersSearchPost (pageSize: number, xTtsAccessToken: string, contentType: string, version?: number, pageToken?: string, shopCipher?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405SearchSellerAffiliateOrdersResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/orders/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'pageSize' is not null or undefined
        if (pageSize === null || pageSize === undefined) {
            throw new Error('Required parameter pageSize was null or undefined when calling OrdersSearchPost.');
        }

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling OrdersSearchPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling OrdersSearchPost.');
        }

        if (version !== undefined) {
            localVarQueryParameters['version'] = ObjectSerializer.serialize(version, "number");
        }

        if (pageToken !== undefined) {
            localVarQueryParameters['page_token'] = ObjectSerializer.serialize(pageToken, "string");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['page_size'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405SearchSellerAffiliateOrdersResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405SearchSellerAffiliateOrdersResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * The user of this API is a partner developer, on behalf of Sellers. This API is used to generate affiliate exclusive product link based on all open collaboration products available within the TikTok Shop Affiliate Product Marketplace. This API generates a link, at the product ID level (which belongs to a Seller). This link, can be distributed to creators, by the partner developer(the user of this API). The creator adds this product to the creators\' showcase through this url. This link, represents an affiliate partner\'s ability to bring higher matchmaking effectiveness on behalf of a seller. If a creator does indeed add the product to showcase through this link, then the downstream consumer purchases will be able to be attributed to this partner due to the link generation capabilities.
     * @summary GenerateAffiliateProductPromotionLink
     * @param productId The product identifier.
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param shopCipher 
     */
    public async ProductsProductIdPromotionLinkGeneratePost (productId: string, xTtsAccessToken: string, contentType: string, shopCipher?: string, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/products/{product_id}/promotion_link/generate'
            .replace('{' + 'product_id' + '}', encodeURIComponent(String(productId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'productId' is not null or undefined
        if (productId === null || productId === undefined) {
            throw new Error('Required parameter productId was null or undefined when calling ProductsProductIdPromotionLinkGeneratePost.');
        }

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling ProductsProductIdPromotionLinkGeneratePost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling ProductsProductIdPromotionLinkGeneratePost.');
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405GenerateAffiliateProductPromotionLinkResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API is used to create a target collaboration. A target collaboration is a collaboration between a seller selected set of products (including a commission payout) and a set of creators the seller has added (invited) to the collaboration. Target collaborations are private and not visible in the Creator Marketplace to all creators; they are only visible to those that have been added to the collaboration.
     * @summary CreateTargetCollaboration
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param shopCipher 
     * @param CreateTargetCollaborationRequestBody 
     */
    public async TargetCollaborationsPost (xTtsAccessToken: string, contentType: string, shopCipher?: string, CreateTargetCollaborationRequestBody?: AffiliateSeller202405CreateTargetCollaborationRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405CreateTargetCollaborationResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202405/target_collaborations';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling TargetCollaborationsPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling TargetCollaborationsPost.');
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(CreateTargetCollaborationRequestBody, "AffiliateSeller202405CreateTargetCollaborationRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202405CreateTargetCollaborationResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202405CreateTargetCollaborationResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}

export const AffiliateSellerV202405ApiOperationNames = {
    OpenCollaborationSettingsPost: 'OpenCollaborationSettingsPost',OpenCollaborationsOpenCollaborationIdRemoveCreatorPost: 'OpenCollaborationsOpenCollaborationIdRemoveCreatorPost',OpenCollaborationsPost: 'OpenCollaborationsPost',OpenCollaborationsProductsSearchPost: 'OpenCollaborationsProductsSearchPost',OrdersSearchPost: 'OrdersSearchPost',ProductsProductIdPromotionLinkGeneratePost: 'ProductsProductIdPromotionLinkGeneratePost',TargetCollaborationsPost: 'TargetCollaborationsPost',
} as const


export type AffiliateSellerV202405ApiOperationTypes = {
    OpenCollaborationSettingsPost: AffiliateSellerV202405Api['OpenCollaborationSettingsPost'];OpenCollaborationsOpenCollaborationIdRemoveCreatorPost: AffiliateSellerV202405Api['OpenCollaborationsOpenCollaborationIdRemoveCreatorPost'];OpenCollaborationsPost: AffiliateSellerV202405Api['OpenCollaborationsPost'];OpenCollaborationsProductsSearchPost: AffiliateSellerV202405Api['OpenCollaborationsProductsSearchPost'];OrdersSearchPost: AffiliateSellerV202405Api['OrdersSearchPost'];ProductsProductIdPromotionLinkGeneratePost: AffiliateSellerV202405Api['ProductsProductIdPromotionLinkGeneratePost'];TargetCollaborationsPost: AffiliateSellerV202405Api['TargetCollaborationsPost'];
};

