/**
 * tiktok shop openapi
 * sdk for apis
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import localVarRequest from 'request';
import http from 'http';

/* tslint:disable:no-unused-locals */
import { AffiliateSeller202507SellerReviewSampleApplicationsRequestBody } from '../model/affiliateSeller/V202507/SellerReviewSampleApplicationsRequestBody';
import { AffiliateSeller202507SellerReviewSampleApplicationsResponse } from '../model/affiliateSeller/V202507/SellerReviewSampleApplicationsResponse';
import { AffiliateSeller202507SellerSearchSampleApplicationsRequestBody } from '../model/affiliateSeller/V202507/SellerSearchSampleApplicationsRequestBody';
import { AffiliateSeller202507SellerSearchSampleApplicationsResponse } from '../model/affiliateSeller/V202507/SellerSearchSampleApplicationsResponse';

import { ObjectSerializer, Authentication, VoidAuth, Interceptor } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'https://open-api.tiktokglobalshop.com';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum AffiliateSellerV202507ApiApiKeys {
}

export class AffiliateSellerV202507Api {
    protected _basePath = defaultBasePath;
    protected _defaultHeaders : any = {};
    protected _useQuerystring : boolean = false;

    static readonly apiName = 'AffiliateSellerV202507Api' as const;

    protected authentications = {
        'default': <Authentication>new VoidAuth(),
    }

    protected interceptors: Interceptor[] = [];

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    set defaultHeaders(defaultHeaders: any) {
        this._defaultHeaders = defaultHeaders;
    }

    get defaultHeaders() {
        return this._defaultHeaders;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: AffiliateSellerV202507ApiApiKeys, value: string) {
        (this.authentications as any)[AffiliateSellerV202507ApiApiKeys[key]].apiKey = value;
    }

    public addInterceptor(interceptor: Interceptor) {
        this.interceptors.push(interceptor);
    }

    /**
     * This API allows the seller to approve or reject the creator\'s sample application in an open collaboration. When rejecting an application, the seller must provide a specific reason. This API facilitates the management of sample applications by giving sellers the ability to review and update applications according to their criteria and requirements.
     * @summary SellerReviewSampleApplications
     * @param applicationId The unique id of sample request application ID
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param shopCipher 
     * @param SellerReviewSampleApplicationsRequestBody 
     */
    public async SampleApplicationsApplicationIdReviewPost (applicationId: string, xTtsAccessToken: string, contentType: string, shopCipher?: string, SellerReviewSampleApplicationsRequestBody?: AffiliateSeller202507SellerReviewSampleApplicationsRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202507SellerReviewSampleApplicationsResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202507/sample_applications/{application_id}/review'
            .replace('{' + 'application_id' + '}', encodeURIComponent(String(applicationId)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'applicationId' is not null or undefined
        if (applicationId === null || applicationId === undefined) {
            throw new Error('Required parameter applicationId was null or undefined when calling SampleApplicationsApplicationIdReviewPost.');
        }

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling SampleApplicationsApplicationIdReviewPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling SampleApplicationsApplicationIdReviewPost.');
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(SellerReviewSampleApplicationsRequestBody, "AffiliateSeller202507SellerReviewSampleApplicationsRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202507SellerReviewSampleApplicationsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202507SellerReviewSampleApplicationsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * This API is provided for sellers to query sample applications based on various criteria such as products, creators, or application statuses. By using this API, sellers can retrieve detailed information about sample application records, including the creator\'s information and the specifics of each application.
     * @summary SellerSearchSampleApplications
     * @param xTtsAccessToken 
     * @param contentType Allowed type: application/json
     * @param pageToken Pagination offset determines where you begin to search for. It\&#39;s empty when raise your first request.
     * @param pageSize The value of \&quot;page_size\&quot; must be greater than 0 and less than or equal to 50.
     * @param shopCipher 
     * @param SellerSearchSampleApplicationsRequestBody 
     */
    public async SampleApplicationsSearchPost (xTtsAccessToken: string, contentType: string, pageToken?: string, pageSize?: number, shopCipher?: string, SellerSearchSampleApplicationsRequestBody?: AffiliateSeller202507SellerSearchSampleApplicationsRequestBody, options: {headers: {[name: string]: string}} = {headers: {}}) : Promise<{ response: http.IncomingMessage; body: AffiliateSeller202507SellerSearchSampleApplicationsResponse;  }> {
        const localVarPath = this.basePath + '/affiliate_seller/202507/sample_applications/search';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this._defaultHeaders);
        const produces = ['application/json'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'xTtsAccessToken' is not null or undefined
        if (xTtsAccessToken === null || xTtsAccessToken === undefined) {
            throw new Error('Required parameter xTtsAccessToken was null or undefined when calling SampleApplicationsSearchPost.');
        }

        // verify required parameter 'contentType' is not null or undefined
        if (contentType === null || contentType === undefined) {
            throw new Error('Required parameter contentType was null or undefined when calling SampleApplicationsSearchPost.');
        }

        if (pageToken !== undefined) {
            localVarQueryParameters['page_token'] = ObjectSerializer.serialize(pageToken, "string");
        }

        if (pageSize !== undefined) {
            localVarQueryParameters['page_size'] = ObjectSerializer.serialize(pageSize, "number");
        }

        if (shopCipher !== undefined) {
            localVarQueryParameters['shop_cipher'] = ObjectSerializer.serialize(shopCipher, "string");
        }

        localVarHeaderParams['x-tts-access-token'] = ObjectSerializer.serialize(xTtsAccessToken, "string");
        localVarHeaderParams['Content-Type'] = ObjectSerializer.serialize(contentType, "string");
        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(SellerSearchSampleApplicationsRequestBody, "AffiliateSeller202507SellerSearchSampleApplicationsRequestBody")
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() => this.authentications.default.applyToRequest(localVarRequestOptions));

        let interceptorPromise = authenticationPromise;
        for (const interceptor of this.interceptors) {
            interceptorPromise = interceptorPromise.then(() => interceptor(localVarRequestOptions));
        }

        return interceptorPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: AffiliateSeller202507SellerSearchSampleApplicationsResponse;  }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            body = ObjectSerializer.deserialize(body, "AffiliateSeller202507SellerSearchSampleApplicationsResponse");
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}

export const AffiliateSellerV202507ApiOperationNames = {
    SampleApplicationsApplicationIdReviewPost: 'SampleApplicationsApplicationIdReviewPost',SampleApplicationsSearchPost: 'SampleApplicationsSearchPost',
} as const


export type AffiliateSellerV202507ApiOperationTypes = {
    SampleApplicationsApplicationIdReviewPost: AffiliateSellerV202507Api['SampleApplicationsApplicationIdReviewPost'];SampleApplicationsSearchPost: AffiliateSellerV202507Api['SampleApplicationsSearchPost'];
};

